import scapy.all as scapy
import os

# 'show module' command shows detailed stats/parameters

pkt_size = int($BESS_PKT_SIZE!'60')
assert(60 <= pkt_size <= 1522)

eth = scapy.Ether(src='02:1e:67:9f:4d:ae', dst='06:16:3e:1b:72:32')
ip = scapy.IP(src='10.0.0.1', dst='10.0.0.2', tos=1)   # dst IP is overwritten
tcp = scapy.TCP(sport=10001, dport=10002)
payload = ('hello' + '0123456789' * 200)[:pkt_size-len(eth/ip/tcp)]
pkt = eth/ip/tcp/payload
pkt_data = bytes(pkt)

# NOTE: without quick_rampup=1, it takes a while to converge to
# the desied load level, especially when flow duration is pareto distribution

f::FlowGen(template=pkt_data, pps=2, flow_rate = 1, flow_duration = 10.0, \
        arrival='exponential', duration='pareto', quick_rampup=True)
decap1::GenericDecap(bytes=14)
decap2::GenericDecap(bytes=14)
s::Sink()
ntf::NTF()

encap1::GenericEncap(fields=[{'size': 6, 'value': {'value_int': 0x020000000001}}, {'size': 6, 'value': {'value_int': 0x0619deadbeef}},{'size': 2, 'value': {'value_int':0x0800}}])
encap2::GenericEncap(fields=[{'size': 6, 'value': {'value_int': 0x0619deadbeef}}, {'size': 6, 'value': {'value_int':0x020000000001 }},{'size': 2, 'value': {'value_int':0x0800}}])


f->decap1->0:ntf:1->encap1->MACSwap()->IPSwap()->decap2->encap2->s # ->decap2->1:ntf:0->encap2->s

open('/tmp/test1.pcap','w').close()
open('/tmp/test2.pcap','w').close()

bess.tcpdump_gate(True, 'test',"encap1", gate=0, direction="out", fifo="/tmp/test1.pcap")
# bess.tcpdump_gate(True, 'test',"encap2", gate=0, direction="out", fifo="/tmp/test2.pcap")